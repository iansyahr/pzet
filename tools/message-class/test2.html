<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Potong Tabel - OPTIMIZED VERSION</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f9; color: #333; max-width: 900px; margin: 20px auto; padding: 20px; box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 8px; }
        h1, h2 { text-align: center; color: #444; }
        #controls { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; padding: 20px; background-color: #fff; border: 1px dashed #ccc; border-radius: 8px; }
        input[type="file"] { padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 12px 20px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        button:hover { background-color: #218838; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }

        #log-container {
            background-color: #2b3035;
            color: #c0c5ce;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
            height: 300px;
            overflow-y: scroll;
            border: 1px solid #444;
        }
        #log-container p {
            margin: 0 0 5px 0;
            padding: 2px 5px;
            white-space: pre-wrap;
        }
        .log-step { font-weight: bold; color: #66d9ef; border-top: 1px solid #555; padding-top: 8px; margin-top: 8px;}
        .log-info { color: #e6e6e6; }
        .log-success { color: #a6e22e; font-weight: bold; }
        .log-error { color: #f92672; font-weight: bold; }
        .log-warning { color: #fd971f; }

        .processing-steps { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 20px; }
        .processing-steps canvas { max-width: 45%; border: 1px solid #ccc; }
        #result-container { text-align: center; }
        #result-container img { max-width: 100%; margin-top: 10px; border: 2px solid #17a2b8; border-radius: 4px; }
    </style>
</head>
<body>

    <h1>Potong Tabel - OPTIMIZED VERSION</h1>
    <p>Versi yang dioptimalkan dengan pre-filtering dan caching untuk performa lebih cepat.</p>

    <div id="controls">
        <label for="imageUpload">Pilih gambar tabel:</label>
        <input type="file" id="imageUpload" accept="image/*">
        <button id="processButton">Mulai Proses Optimized</button>
    </div>

    <h2>Log Proses</h2>
    <div id="log-container">
        <p class="log-info">Memuat library, harap tunggu...</p>
    </div>
    
    <div class="processing-steps">
        <canvas id="canvasPreview" style="display:none;"></canvas>
    </div>

    <div id="result-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script async src="https://docs.opencv.org/4.9.0/opencv.js" onload="onOpenCvReady();"></script>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const processButton = document.getElementById('processButton');
        const logContainer = document.getElementById('log-container');
        const resultContainer = document.getElementById('result-container');
        const canvasPreview = document.getElementById('canvasPreview');
        
        // Cache untuk reuse workers
        let globalScheduler = null;
        let workersReady = false;
        
        processButton.disabled = true;

        function logToUI(message, type = 'info') {
            const p = document.createElement('p');
            p.textContent = message;
            p.className = `log-${type}`;
            logContainer.appendChild(p);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        async function initializeScheduler() {
            if (globalScheduler && workersReady) return;
            
            logToUI('Inisialisasi Tesseract scheduler (hanya sekali)...', 'info');
            globalScheduler = Tesseract.createScheduler();
            
            const numWorkers = Math.min(navigator.hardwareConcurrency || 4, 6); // Batasi max workers
            
            for (let i = 0; i < numWorkers; i++) {
                const worker = await Tesseract.createWorker('eng', {
                    // Optimasi konfigurasi worker
                    langPath: 'https://tessdata.projectnaptha.com/4.0.0',
                    workerBlobURL: false,
                    workerPath: 'https://unpkg.com/tesseract.js@v5.0.0/dist/worker.min.js',
                    corePath: 'https://unpkg.com/tesseract.js-core@v5.0.0/tesseract-core-simd.wasm.js',
                });
                
                // Set parameter OCR untuk speed
                await worker.setParameters({
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,()-',
                });
                
                globalScheduler.addWorker(worker);
            }
            
            workersReady = true;
            logToUI(`${numWorkers} workers siap dan dikonfigurasi untuk speed.`, 'success');
        }

        function onOpenCvReady() {
            cv.onRuntimeInitialized = async () => {
                console.log('OpenCV runtime is now ready.');
                await initializeScheduler();
                processButton.disabled = false;
                logToUI('Sistem siap. Workers sudah di-cache untuk proses berikutnya.', 'success');
            };
        }

        // Pre-filter fungsi untuk mengurangi OCR yang tidak perlu
        function preFilterCells(cellRects, binary) {
            logToUI('  > Pre-filtering sel dengan deteksi teks cepat...', 'info');
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            
            return cellRects.filter(rect => {
                // Ambil sample kecil dari sel untuk cek apakah ada teks
                let cellMat = binary.roi(rect);
                cv.imshow(tempCanvas, cellMat);
                
                // Hitung rasio pixel putih (teks)
                const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const pixels = imageData.data;
                let whitePixels = 0;
                
                for (let i = 0; i < pixels.length; i += 4) {
                    if (pixels[i] > 128) whitePixels++; // Pixel putih
                }
                
                const whiteRatio = whitePixels / (pixels.length / 4);
                cellMat.delete();
                
                // Filter sel yang kemungkinan mengandung teks (5-50% pixel putih)
                return whiteRatio > 0.05 && whiteRatio < 0.5;
            });
        }

        processButton.addEventListener('click', () => {
            const file = imageUpload.files[0];
            if (!file) { logToUI('Silakan pilih file gambar terlebih dahulu!', 'error'); return; }
            
            logContainer.innerHTML = '';
            resultContainer.innerHTML = '';
            canvasPreview.style.display = 'none';

            processButton.disabled = true;
            processButton.textContent = 'Memproses...';
            logToUI('Proses dimulai...', 'info');

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => startAdvancedProcessing(img);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        async function startAdvancedProcessing(img) {
            try {
                logToUI('Langkah 1: Pra-pemrosesan Gambar Optimized', 'step');
                
                // Resize gambar jika terlalu besar untuk speed
                const maxWidth = 1200;
                const scaleFactor = img.width > maxWidth ? maxWidth / img.width : 1;
                
                let src = cv.imread(img);
                if (scaleFactor < 1) {
                    let resized = new cv.Mat();
                    cv.resize(src, resized, new cv.Size(img.width * scaleFactor, img.height * scaleFactor));
                    src.delete();
                    src = resized;
                    logToUI(`  > Gambar di-resize dengan faktor ${scaleFactor.toFixed(2)} untuk optimasi.`, 'info');
                }
                
                let gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                
                // Optimasi preprocessing
                let blur = new cv.Mat();
                cv.GaussianBlur(gray, blur, new cv.Size(3, 3), 0);
                
                let binary = new cv.Mat();
                cv.adaptiveThreshold(blur, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
                
                // Morfologi untuk membersihkan noise
                let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                cv.morphologyEx(binary, binary, cv.MORPH_CLOSE, kernel);
                
                logToUI('  > Preprocessing optimized selesai.', 'info');
                blur.delete();
                kernel.delete();

                canvasPreview.style.display = 'block';
                cv.imshow(canvasPreview, binary);
                
                logToUI('Langkah 2: Deteksi Sel dengan Filter Area', 'step');
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                const cellRects = [];
                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    // Optimasi: Filter area yang lebih ketat
                    if (area > 800 && area < 20000) {
                        let rect = cv.boundingRect(cnt);
                        // Filter aspek rasio yang masuk akal untuk sel tabel
                        let aspectRatio = rect.width / rect.height;
                        if (aspectRatio > 0.2 && aspectRatio < 10) {
                            cellRects.push(rect);
                        }
                    }
                    cnt.delete();
                }
                
                if (cellRects.length === 0) {
                    throw new Error("Tidak ditemukan sel tabel yang valid.");
                }
                
                logToUI(`  > Ditemukan ${cellRects.length} kandidat sel.`, 'info');

                // Pre-filter untuk mengurangi beban OCR
                const filteredCells = preFilterCells(cellRects, binary);
                logToUI(`  > Setelah pre-filter: ${filteredCells.length} sel akan di-OCR.`, 'success');

                logToUI('Langkah 3: OCR Paralel dengan Target Spesifik', 'step');
                
                const tempCanvas = document.createElement('canvas');
                let completedCount = 0;

                // OCR hanya sel yang sudah difilter
                const ocrPromises = filteredCells.map(rect => {
                    let cellMat = binary.roi(rect);
                    
                    // Optimasi: resize sel jika terlalu kecil
                    if (rect.width < 50 || rect.height < 20) {
                        let resized = new cv.Mat();
                        cv.resize(cellMat, resized, new cv.Size(rect.width * 2, rect.height * 2));
                        cellMat.delete();
                        cellMat = resized;
                    }
                    
                    cv.imshow(tempCanvas, cellMat);
                    const imageDataUrl = tempCanvas.toDataURL('image/png');
                    cellMat.delete();
                    
                    return globalScheduler.addJob('recognize', imageDataUrl)
                        .then(result => {
                            completedCount++;
                            logToUI(`  > OCR Progress: ${completedCount}/${filteredCells.length}`, 'info');
                            return { result, rect };
                        });
                });

                const resultsWithRects = await Promise.all(ocrPromises);
                logToUI(`  > OCR paralel selesai!`, 'success');
                
                const ocrResults = resultsWithRects
                    .filter(({ result }) => result.data.text.trim())
                    .map(({ result, rect }) => ({
                        text: result.data.text.trim().replace(/\n/g, ' '),
                        rect: { 
                            x: rect.x / scaleFactor, 
                            y: rect.y / scaleFactor, 
                            width: rect.width / scaleFactor, 
                            height: rect.height / scaleFactor 
                        } // Scale back ke ukuran asli
                    }));

                logToUI('Langkah 4: Pencarian Target dengan Fuzzy Matching', 'step');
                
                // Fuzzy matching untuk lebih robust
                const itaCells = ocrResults.filter(r => 
                    r.text.toUpperCase().includes('ITA') || 
                    r.text.toUpperCase().includes('ITO') || // OCR kadang salah baca
                    r.text.toUpperCase().includes('ITR')
                );
                
                const numCells = ocrResults.filter(r => 
                    r.text.includes('3550') ||
                    r.text.includes('3500') || // Toleransi OCR error
                    r.text.includes('3580')
                );
                
                logToUI(`  > Ditemukan ${itaCells.length} sel 'ITA-like' dan ${numCells.length} sel '3550-like'.`, 'info');

                let targetRow = null;
                for (const itaCell of itaCells) {
                    for (const numCell of numCells) {
                        const isSameRow = (itaCell.rect.y < numCell.rect.y + numCell.rect.height && 
                                           itaCell.rect.y + itaCell.rect.height > numCell.rect.y);
                        if (isSameRow) {
                            logToUI(`  > Match found! ITA: y=${Math.round(itaCell.rect.y)}, NUM: y=${Math.round(numCell.rect.y)}`, 'success');
                            const rowCenterY = (itaCell.rect.y + itaCell.rect.height / 2);
                            targetRow = ocrResults.filter(r => Math.abs((r.rect.y + r.rect.height / 2) - rowCenterY) < itaCell.rect.height / 2);
                            break;
                        }
                    }
                    if (targetRow) break;
                }

                if (!targetRow || targetRow.length === 0) {
                    throw new Error('Target row tidak ditemukan. Coba dengan gambar yang lebih jelas.');
                }
                
                logToUI(`  > Target row: ${targetRow.length} sel ditemukan.`, 'success');

                logToUI('Langkah 5: Crop Final', 'step');
                const padding = 10;
                const minX = Math.min(...targetRow.map(r => r.rect.x)) - padding;
                const minY = Math.min(...targetRow.map(r => r.rect.y)) - padding;
                const maxX = Math.max(...targetRow.map(r => r.rect.x + r.rect.width)) + padding;
                const maxY = Math.max(...targetRow.map(r => r.rect.y + r.rect.height)) + padding;
                
                // Crop dari gambar asli (bukan yang di-resize)
                let originalSrc = cv.imread(img);
                const finalRect = new cv.Rect(Math.max(0, minX), Math.max(0, minY), maxX - minX, maxY - minY);
                let finalCrop = originalSrc.roi(finalRect);
                
                const resultCanvas = document.createElement('canvas');
                cv.imshow(resultCanvas, finalCrop);
                
                resultContainer.innerHTML = '<h2>Hasil Optimized:</h2>';
                const resultImage = new Image();
                resultImage.src = resultCanvas.toDataURL('image/png');
                resultContainer.appendChild(resultImage);

                logToUI('PROSES OPTIMIZED SELESAI! ðŸš€', 'success');
                
                // Cleanup
                src.delete(); gray.delete(); binary.delete(); contours.delete(); 
                hierarchy.delete(); finalCrop.delete(); originalSrc.delete();

            } catch (error) {
                console.error("Error:", error);
                logToUI(`Error: ${error.message}`, 'error');
            } finally {
                processButton.disabled = false;
                processButton.textContent = 'Mulai Proses Optimized';
            }
        }

        // Cleanup saat page unload
        window.addEventListener('beforeunload', async () => {
            if (globalScheduler && workersReady) {
                await globalScheduler.terminate();
            }
        });
    </script>

</body>
</html>
